#!/bin/bash

################################################################################
# Copywrite Daniel Mills <danielmills1@gmail.com>                              #
# Thanks to Patrick Brisbin <pbrisbin@gmail.com>, for the .PKGINFO tip         #
#                                                                              #
# Permission is hereby granted, free of charge, to any person obtaining a copy #
# of this software and associated documentation files (the "Software"), to     #
# deal in the Software without restriction, including without limitation the   #
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or  #
# sell copies of the Software, and to permit persons to whom the Software is   #
# furnished to do so, subject to the following conditions:                     #
#                                                                              #
# The above copyright notice and this permission notice shall be included in   #
# all copies or substantial portions of the Software.                          #
#                                                                              #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR   #
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,     #
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  #
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER       #
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING      #
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS #
# IN THE SOFTWARE.                                                             #
#                                                                              #
# Requires bash4, libarchive, awk                                              #
# Optional deps: sudo (recommended)                                            #
################################################################################

shopt -s nullglob extglob

cachedir=/var/cache/pacman/pkg
lock_file=${XDG_CACHE_HOME:-$HOME/.cache}/clearcache.lck
tokeep=1; toremove=()
v=0; list=0; force=0; uninst=0; targets=(); options=(); toremove_tot=0
declare -A pkgs_v pkgs_c toremove_v toremove_c installed ignore 

usage() {
cat <<'EOF'
usage: clearcache [options] [targets]

 Options:
  -h, --help          display this help menu
  -f, --force         force removal of package files
  -i, --ignore <pkg>  specify package(s) to ignore. this can be a comma
                      separated list, or '-' reads a list from stdin, one
                      per line. can be used more than once.
  -k, --keep <num>    specify number of old package files to keep
  -l, --list-targets  list targets to remove, using PAGER/less, before 
                      removing
  -u, --uninstalled   remove all package files for packages that are not
                      currently installed, while still keeping the
                      specified number of old files for installed packages
  -v, --verbose       output more

  there MUST be a space between the option and its argument.

 Targets:
  targets are package names, as you would specify them to pacman.
  if targets are specified, only package files belonging to them will be
  removed. if no targets are specified, all packages except for thos
  specified to be ignored will be removed.
EOF
}

runasroot() {
  if sudo -v &>/dev/null && sudo -l "$@" &>/dev/null; then
    sudo "$@"
  else
    printf '%s ' "Root"
    su -c "$(printf '%q ' "$@")"
  fi
}

{
flock -n 9 || {
  printf '%s\n' 'only one instance may be running at a time' \
                "if you are sure that another instance isn't running,"
                "remove '$lock_file'"

while (($#)); do
  case $1 in
    -[!-]?*)
      for ((i=1; i<${#1}; i++)); do
        options+=(-"${1:i:1}")
      done
      ;;
    --?*=*) options+=("${1%%=*}" "${1#*=}");;
    *) options+=("$1");;
  esac
  shift
done
set -- "${options[@]}"

while [[ $1 = -?* ]]; do
  case $1 in
    -h|--help) usage; exit;;
    -v|--verbose) v=1; shift;;
    -f|--force) force=1; shift;;
    -l|--list-targets) list=1; shift;;
    -u|--uninstalled) uninst=1; shift;;
    -k|--keep) 
      [[ -z $2 || $2 = *[!0-9]* ]] && {
        printf '%s\n' "invalid number for -k: '$2'" >&2
        exit 1
      }
      tokeep=$2
      shift 2
      ;;
    -i|--ignore)
      [[ $2 ]] || {
        printf '%s\n' "must specify at least one package" >&2
        exit 1
      }
      if [[ $2 = - ]]; then
        if [[ -t 0 ]]; then
          printf '%s\n' "stdin is a terminal, no list was read" >&2
        else
          while read -r pkg; do
            ignore[$pkg]=1
          done
        fi
      else
        IFS=, read -ra newignore <<<"$2"
        for pkg in "${newignore[@]}"; do
          ignore[$pkg]=1
        done
      fi
      shift 2
      ;;
      *)
        printf '%s\n' "invalid option: '$1'" >&2
        exit 1
        ;;
  esac
done

targets=("$@")

cd "$cachedir" || {
  printf '%s\n' "could not cd to '$cachedir'" >&2
  exit 1
}

if ((uninst)); then
  ((v)) && printf '%s\n' "obtaining list of currently installed packages..."
  while read -r pkg; do
    installed[$pkg]=1
  done < <(pacman -Qq)
fi

((v)) && printf '%s\n' "obtaining list of packages in '$cachedir'..."

if ((${#targets[@]})); then
  for t in "${targets[@]}"; do
    files+=("$t"-[0-9]*.pkg.tar.?z)
  done
else
  files=(*.pkg.tar.?z)
fi

for f in "${files[@]}"; do
  case $f in
    *.gz) opts='-qxzf';;
    *.xz) opts='-qxJf';;
    *) printf '%s\n' "unsupported compression for '$f', skipping" >&2
      continue;;
  esac
  read -r pkg < <(bsdtar -O "$opts" "$f" .PKGINFO |
      awk -F '[[:blank:]]*=[[:blank:]]*' '$1 == "pkgname" {print $2}')
  ((ignore[$pkg])) && continue
  ((pkgs_c[$pkg]++)); pkgs_v[$pkg,${pkgs_c[$pkg]}]=$f
done

((v)) && printf '%s\n' "determining which packages to remove..."
for pkg in "${!pkgs_c[@]}"; do
  ((pkgs_c[$pkg] > tokeep)) || continue
  {
    if ((installed[$pkg])); then
      for ((i=0; i<tokeep; i++)); do
        read -d ''
      done
    fi
    while IFS= read -rd '' f; do
      ((toremove_c[$pkg]++, toremove_tot++))
      toremove_v[$pkg,${toremove_c[$pkg]}]=$f
      toremove+=("$f")
    done
  } < <(for ((i=1; i<=pkgs_c[$pkg]; i++)); do
          printf '%s\0' "${pkgs_v[$pkg,$i]}"
        done | sort -Vrz)
done

((toremove_tot)) || {
  printf '%s\n' "There is nothing to do."
  exit 1
}

printf '%s\n' "Removing '$toremove_tot' packages from '$cachedir'"

if ((list)); then
  printf '%s\0' "${!toremove_c[@]}" | sort -z | while IFS= read -rd '' pkg; do
    printf '%s:\n' "$pkg"
    for ((i=1; i<=toremove_c[$pkg]; i++)); do
      printf '  %s\n' "${toremove_v[$pkg,$i]}"
    done
  done | ${PAGER:-less}
fi

declare -l reply
[[ -t 0 ]] || exec </dev/tty
read -p 'Continue? [Y/n] ' reply
[[ $reply && $reply != y?(es) ]] && exit

if ((force)); then
  runasroot rm -f "${toremove[@]}"
else
  runasroot rm "${toremove[@]}" || {
    printf '%s\n' "could not remove files" >&2
  }
fi
} 9>"$lock_file"
