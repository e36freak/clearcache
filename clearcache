#!/bin/bash

################################################################################
# Copywrite Daniel Mills <danielmills1@gmail.com>                              #
# Thanks to Patrick Brisbin <pbrisbin@gmail.com>, for the .PKGINFO tip         #
#                                                                              #
# Permission is hereby granted, free of charge, to any person obtaining a copy #
# of this software and associated documentation files (the "Software"), to     #
# deal in the Software without restriction, including without limitation the   #
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or  #
# sell copies of the Software, and to permit persons to whom the Software is   #
# furnished to do so, subject to the following conditions:                     #
#                                                                              #
# The above copyright notice and this permission notice shall be included in   #
# all copies or substantial portions of the Software.                          #
#                                                                              #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR   #
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,     #
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  #
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER       #
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING      #
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS #
# IN THE SOFTWARE.                                                             #
#                                                                              #
# Requires bash4, libarchive, awk                                              #
# Optional deps: sudo (recommended)                                            #
################################################################################
# TODO: option to parse pacman output and know which version of the package is #
#         actually installed                                                   #
################################################################################

shopt -s nullglob extglob

cachedir=/var/cache/pacman/pkg
lock_file=${XDG_CACHE_HOME:-$HOME/.cache}/clearcache.lck
fifo=/tmp/clearcache.fifo.$$
tokeep=2; toremove=(); threads=5; dry=0; quiet=0
v=0; list=0; force=0; uninst=0; targets=(); options=(); toremove_tot=0
declare -A pkgs_v pkgs_c toremove_v toremove_c installed ignore 

usage() {
cat <<'EOF'
usage: clearcache [options] [targets]

 Options:
  -h, --help          display this help menu
  -d, --dry           dry run, simply list targets instead of removing
  -q, --quiet         only prints filenames for -d/--dry or -l/--list-targets
  -f, --force         force removal of package files
  -i, --ignore <pkg>  specify package(s) to ignore. this can be a comma
                      separated list, or '-' reads a list from stdin, one
                      per line. can be used more than once.
  -k, --keep <num>    specify number of old package files to keep. by default,
                      clearcache will keep the two most recent versions.
  -l, --list-targets  list targets to remove, using PAGER/less, before 
                      removing. may not be used with -d/--dry
  -t, --threads <num> use <num> threads. the default value is 5. using a
                      large number will not gain you much, and is not 
                      recommended, but there is no hard limit.
  -u, --uninstalled   remove all package files for packages that are not
                      currently installed, while still keeping the
                      specified number of old files for installed packages
  -v, --verbose       output more

  there MUST be a space between the option and its argument.

 Targets:
  targets are package names, as you would specify them to pacman.
  if targets are specified, only package files belonging to them will be
  removed. if no targets are specified, all packages except for thos
  specified to be ignored will be removed.
EOF
}

runasroot() {
  if sudo -v &>/dev/null && sudo -l "$@" &>/dev/null; then
    sudo "$@"
  else
    printf '%s ' "Root"
    su -c "$(printf '%q ' "$@")"
  fi
}

parse() {
  local opts
  case $1 in
    *.gz) opts='-qxzf';;
    *.xz) opts='-qxJf';;
  esac
  bsdtar -O "$opts" "$1" .PKGINFO |
    awk -F '[[:blank:]]*=[[:blank:]]*' -v f="$1" '
      $1 == "pkgname" {printf("%s %s\n", f, $2); exit}' >&3
}

print_targets() {
  printf '%s\0' "${!toremove_c[@]}" | sort -z | while IFS= read -rd '' pkg; do
    ((!quiet)) && printf '%s:\n' "$pkg"
    for ((i=1; i<=toremove_c[$pkg]; i++)); do
      if ((quiet)); then
        printf '%s\n' "${toremove_v[$pkg,$i]}"
      else
        printf '  %s\n' "${toremove_v[$pkg,$i]}"
      fi
    done
  done
}

((UID == 0)) && {
  printf '%s\n' 'do not run this as root, you will be prompted' >&2
  exit 1
}

{
flock -n 9 || {
  printf '%s\n' 'only one instance may be running at a time' \
                "if you are sure that another instance isn't running,"
                "remove '$lock_file'"
  exit 1
}

while (($#)); do
  case $1 in
    -[!-]?*)
      for ((i=1; i<${#1}; i++)); do
        options+=(-"${1:i:1}")
      done
      ;;
    --?*=*) options+=("${1%%=*}" "${1#*=}");;
    --) options+=(--end);;
    *) options+=("$1");;
  esac
  shift
done
set -- "${options[@]}"

while [[ $1 = -?* ]]; do
  case $1 in
    -h|--help) usage; exit;;
    -v|--verbose) v=1; shift;;
    -d|--dry) dry=1; shift;;
    -f|--force) force=1; shift;;
    -l|--list-targets) list=1; shift;;
    -u|--uninstalled) uninst=1; shift;;
    -q|--quiet) quiet=1; shift;;
    -t|--threads)
      [[ $2 != *[!0-9]* ]] && (($2 > 0)) || {
        printf '%s\n' "invalid number of threads: '$2'" >&2
        exit 1
      }
      threads=$2
      shift 2
      ;;
    -k|--keep) 
      [[ -z $2 || $2 = *[!0-9]* ]] && {
        printf '%s\n' "invalid number for -k: '$2'" >&2
        exit 1
      }
      tokeep=$2
      shift 2
      ;;
    -i|--ignore)
      [[ $2 ]] || {
        printf '%s\n' "must specify at least one package" >&2
        exit 1
      }
      if [[ $2 = - ]]; then
        if [[ -t 0 ]]; then
          printf '%s\n' "stdin is a terminal, no list was read" >&2
        else
          while read -r pkg; do
            ignore[$pkg]=1
          done
          exec </dev/tty
        fi
      else
        IFS=, read -ra newignore <<<"$2"
        for pkg in "${newignore[@]}"; do
          ignore[$pkg]=1
        done
      fi
      shift 2
      ;;
      --end) shift; break;;
      *)
        printf '%s\n' "invalid option: '$1'" >&2
        exit 1
        ;;
  esac
done

((dry && list)) && {
  printf '%s\n' 'may not use both -d/--dry and -l/--list' >&2
  exit 1
}

targets=("$@")

cd "$cachedir" || {
  printf '%s\n' "could not cd to '$cachedir'" >&2
  exit 1
}

if ((uninst)); then
  ((v)) && printf '%s\n' "obtaining list of currently installed packages..."
  while read -r pkg; do
    installed[$pkg]=1
  done < <(pacman -Qq)
fi

((v)) && printf '%s\n' "obtaining list of packages in '$cachedir'..."

if ((${#targets[@]})); then
  for t in "${targets[@]}"; do
    files+=("$t"-[0-9]*.pkg.tar.[gx]z)
  done
else
  files=(*.pkg.tar.[gx]z)
fi

# now the fun starts
mkfifo "$fifo" || {
  printf '%s\n' "couldn't create fifo '$fifo'" >&2
  exit 1
}
exec 3<>"$fifo"
totfiles=${#files[@]}
for ((curfile=0; curfile<threads; curfile++)); do
  ((curfile < totfiles)) && parse "${files[curfile]}" &
done
while read -r file pkg; do
  ((curfile < totfiles)) && parse "${files[curfile]}" &
  ((ignore[$pkg])) && continue
  ((pkgs_c[$pkg]++)); pkgs_v[$pkg,${pkgs_c[$pkg]}]=$file
  ((++curfile == totfiles)) && break
done <&3
exec 3>&-

((v)) && printf '%s\n' "determining which packages to remove..."
for pkg in "${!pkgs_c[@]}"; do
  ((pkgs_c[$pkg] > tokeep)) || continue
  {
    if ((!uninst || installed[$pkg])); then
      for ((i=0; i<tokeep; i++)); do
        read -d ''
      done
    fi
    while IFS= read -rd '' f; do
      ((toremove_c[$pkg]++, toremove_tot++))
      toremove_v[$pkg,${toremove_c[$pkg]}]=$f
      toremove+=("$f")
    done
  } < <(for ((i=1; i<=pkgs_c[$pkg]; i++)); do
          printf '%s\0' "${pkgs_v[$pkg,$i]}"
        done | sort -Vrz)
done

((toremove_tot)) || {
  printf '%s\n' "There is nothing to do."
  exit 1
}

((dry)) || printf '%s\n' "Removing '$toremove_tot' packages from '$cachedir'"
if ((list)); then
  print_targets | ${PAGER:-less} 
elif ((dry)); then
  print_targets
  exit
fi

declare -l reply
read -p 'Continue? [Y/n] ' reply >/dev/tty
[[ $reply && $reply != y?(es) ]] && exit

if ((force)); then
  runasroot rm -f "${toremove[@]}"
else
  runasroot rm "${toremove[@]}" || {
    printf '%s\n' "could not remove files" >&2
  }
fi
} 9>"$lock_file"
